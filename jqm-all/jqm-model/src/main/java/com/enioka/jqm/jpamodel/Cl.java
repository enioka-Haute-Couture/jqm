package com.enioka.jqm.jpamodel;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;
import javax.persistence.OrderColumn;
import javax.persistence.Table;

/**
 * <strong>Not part of any API - this an internal JQM class and may change without notice.</strong> <br>
 * JPA persistence class for storing the definition of the class loaders used by the {@link JobDef}.
 */
@Entity
@Table(name = "Cl")
public class Cl implements Serializable
{
    private static final long serialVersionUID = -965329631668297388L;

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

    @Column(length = 50, nullable = false, unique = true)
    private String name;

    @Column(name = "childFirst", nullable = false)
    private boolean childFirst = false;

    @Column(length = 1024, name = "hiddenClasses", nullable = true)
    private String hiddenClasses;

    @Column(name = "trace", nullable = false)
    private boolean tracingEnabled = false;

    @Column(name = "persistent", nullable = false)
    private boolean persistent = false;

    @Column(length = 1024, name = "runners", nullable = true)
    private String allowedRunners;

    @OneToMany(orphanRemoval = true, cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JoinColumn(name = "Cl")
    @OrderColumn(name = "idx")
    private List<ClHandler> handlers = new ArrayList<ClHandler>();

    /**
     * A technical ID without any meaning. Generated by the database.
     */
    public Integer getId()
    {
        return id;
    }

    /**
     * See {@link #setId(Integer)}
     */
    public void setId(Integer id)
    {
        this.id = id;
    }

    /**
     * The key used to identify the class loader in the deployment descriptor. Unique.
     */
    public String getName()
    {
        return name;
    }

    /**
     * See {@link #getName()}
     */
    public void setName(String name)
    {
        this.name = name;
    }

    /**
     * Offer option to have child first class loading. Default should stay parent first, as it is the norm in JSE.
     */
    public boolean isChildFirst()
    {
        return childFirst;
    }

    /**
     * See {@link #isChildFirst()}
     */
    public void setChildFirst(boolean childFirst)
    {
        this.childFirst = childFirst;
    }

    /**
     * Offer possibility to hide Java classes from jobs. One or more regex defining classes never to load from the parent class loader.
     */
    public String getHiddenClasses()
    {
        return hiddenClasses;
    }

    /**
     * See {@link #getHiddenClasses()}
     */
    public void setHiddenClasses(String hiddenClasses)
    {
        this.hiddenClasses = hiddenClasses;
    }

    /**
     * Activate listing all class loaded inside the job log
     */
    public boolean isTracingEnabled()
    {
        return tracingEnabled;
    }

    /**
     * See {@link #isTrace()}
     * 
     * @param trace
     */
    public void setTracingEnabled(boolean trace)
    {
        this.tracingEnabled = trace;
    }

    /**
     * The different event handlers associated to this class loader. Ordered list.
     */
    public List<ClHandler> getHandlers()
    {
        return handlers;
    }

    /**
     * See {@link #getHandlers()}
     */
    public void setHandlers(List<ClHandler> handlers)
    {
        this.handlers = handlers;
    }

    /**
     * Default is false. When false, the class loader is transient: it is created to run a new job instance and is thrown out when the job
     * instance ends. When true, it is not thrown out at the end and will be reused by all job instances created from the different
     * {@link JobDef}s using this {@link Cl} (therefore, multiple {@link JobDef}s can share the same static context).
     */
    public boolean isPersistent()
    {
        return persistent;
    }

    /**
     * See {@link #isPersistent()}
     */
    public void setPersistent(boolean persistent)
    {
        this.persistent = persistent;
    }

    /**
     * The different runners that are active in this context. If null, the global parameter job_runners is used instead.
     */
    public String getAllowedRunners()
    {
        return allowedRunners;
    }

    /**
     * See {@link #getAllowedRunners()}
     */
    public void setAllowedRunners(String allowedRunners)
    {
        this.allowedRunners = allowedRunners;
    }
}
