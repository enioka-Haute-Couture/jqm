'use strict';

import template from './node.list.template.html';
import { createGlobalFilter } from '../../helpers/filters';

class QueueMappingListCtrl
{
	constructor($scope, $http, µQueueMappingDto, µQueueDto, µNodeDto, jqmCellTemplateBoolean, jqmCellEditorTemplateBoolean, uiGridConstants, $interval)
	{
		var ctx = this;

		this.mappings = null;
		this.queues = [];
		this.nodes = [];
		this.selected = [];
		this.bDbBusy = false;
		this.error = null;

		this.filterOptions = {
			filterText: '',
		};

		this.gridOptions = {
			data: '$ctrl.mappings',

			enableSelectAll: false,
			enableRowSelection: true,
			enableRowHeaderSelection: true,
			enableFullRowSelection: false,
			enableFooterTotalSelected: false,
			multiSelect: true,
			enableSelectionBatchEvent: false,
			noUnselect: false,

			onRegisterApi: function (gridApi)
			{
				ctx.gridApi = gridApi;
				gridApi.selection.on.rowSelectionChanged(null, function (rows)
				{
					ctx.selected = gridApi.selection.getSelectedRows();
				});
				ctx.gridApi.grid.registerRowsProcessor(createGlobalFilter(ctx, ['node.name', 'queue.name']), 200);
			},

			enableColumnMenus: false,
			enableCellEditOnFocus: true,
			virtualizationThreshold: 20,
			enableHorizontalScrollbar: 0,

			columnDefs: [
				{
					field: 'nodeId',
					displayName: 'Node',
					cellTemplate: '<div class="ui-grid-cell-contents"><span ng-cell-text>{{ (row.entity["nodeId"] | getByProperty:"id":grid.appScope.nodes).name }}</span></div>',
					editableCellTemplate: 'ui-grid/dropdownEditor',
					editDropdownValueLabel: 'name',
					editDropdownOptionsArray: $scope.nodes,
				},
				{
					field: 'queueId',
					displayName: 'Queue',
					cellTemplate: '<div class="ui-grid-cell-contents"><span ng-cell-text>{{ (row.entity["queueId"] | getByProperty:"id":grid.appScope.queues).name }}</span></div>',
					editableCellTemplate: 'ui-grid/dropdownEditor',
					editDropdownValueLabel: 'name',
					editDropdownOptionsArray: $scope.queues,
				},
				{
					field: 'pollingInterval',
					displayName: 'Polling Interval (ms)',
					editableCellTemplate: '<div><form name="inputForm"><input type="number" min="100" max="10000000" ng-required="true" ng-class="\'colt\' + col.uid" ui-grid-editor ng-model="MODEL_COL_FIELD" /></form></div>',
				},
				{
					field: 'nbThread',
					displayName: 'Max concurrent running instances',
					editableCellTemplate: '<div><form name="inputForm"><input type="number" min="1" max="1000" ng-required="true" ng-class="\'colt\' + col.uid" ui-grid-editor ng-model="MODEL_COL_FIELD" /></form></div>',
				}, {
					field: 'enabled',
					displayName: 'Enabled',
					cellTemplate: jqmCellTemplateBoolean,
					editableCellTemplate: jqmCellEditorTemplateBoolean,
					width: '*',
				},]
		};

		$scope.$watch('mappings', function (newMappings)
		{
			var q = null;
			var nodes = {};
			for (var i = 0; i < newMappings.length; i++)
			{
				q = newMappings[i];
				if (!(q.nodeId in nodes))
				{
					nodes[q.nodeId] = [];
				}
				var nodeMappings = nodes[q.nodeId];

				if (nodeMappings.indexOf(q.queueId) != -1)
				{
					$scope.error = {
						"userReadableMessage": "Cannot have two mappings for the same queue inside a single node",
						"errorCode": null,
					};
					return;
				}
				nodeMappings.push(q.queueId);
			}

			// If here, no duplicates
			$scope.error = null;
		}, true);

		this.refresh();
	}

	newmapping()
	{
		var t = new µQueueMappingDto({
			nodeId: this.nodes[0].id,
			queueId: this.queues[0].id,
			nbThread: 10,
			pollingInterval: 60000,
		});
		this.mappings.push(t);
		this.gridApi.selection.selectRow(t);
		var ctx = this;
		$interval(function ()
		{
			ctx.gridApi.cellNav.scrollToFocus(t, ctx.gridOptions.columnDefs[0]);
		}, 0, 1);
	};

	save()
	{
		// Save and refresh the table - ID may have been
		// generated by the server.
		this.bDbBusy = true;
		µQueueMappingDto.saveAll({}, this.mappings, this.refresh);
	};

	refresh()
	{
		this.selected.length = 0;
		this.mappings = µQueueMappingDto.query();
		var ctx = this;

		µQueueDto.query().$promise.then(function (data)
		{
			ctx.queues.length = 0;
			Array.prototype.push.apply(ctx.queues, data);
		});
		µNodeDto.query().$promise.then(function (data)
		{
			ctx.nodes.length = 0;
			Array.prototype.push.apply(ctx.nodes, data);
		});

		ctx.bDbBusy = false;
	};

	remove()
	{
		var q = null;
		for (var i = 0; i < this.selected.length; i++)
		{
			q = this.selected[i];
			if (q.id !== null && q.id !== undefined)
			{
				q.$remove({
					id: q.id
				});
			}
			this.mappings.splice(this.mappings.indexOf(q), 1);
		}
		this.selected.length = 0;
	};
}

jqmControllers.filter('getByProperty', function ()
{
	return function (propertyValue, propertyName, collection)
	{
		var i = 0, len = collection.length;
		for (; i < len; i++)
		{
			if (collection[i][propertyName] === +propertyValue)
			{
				return collection[i];
			}
		}
		return null;
	};
});
